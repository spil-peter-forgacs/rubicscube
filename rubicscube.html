<!DOCTYPE html>
<!-- The previous line tells the browser, that the page uses the HTML5 standard. -->

<html>
<head>
    <title>Rubic's cube</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    
    <!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
    to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
    <style type="text/css">
        body {
            /* Set the background color of the HTML page to black. */
            background-color: #000000;
            /* Hide oversized content. This prevents the scroll bars. */
            overflow: hidden;
        }
    </style>
    <!-- Include libraries.
    1. Three.js (core library)
    2. Detector.js (checks the browsers WebGL capabilities) -->
    <script src="js/three.min.js"></script>
    <script src="js/detector.js"></script>
    <script src="js/mouse.js"></script>
</head>
<body>
<script>
// Global objects.
var scene, camera, renderer;
var geometry, material, mesh;
var rubicsCube;
var rubicsPage = [];
var cubeMesh = [];
var cubePage = [];
var xAxis, yAxis, zAxis;
var rotateX, rotateY, rotateZ;
var clickPoint;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

window.addEventListener( 'resize', onWindowResize, false );

initializeScene();
animateScene();

function initializeScene() {
    // Setup renderer.
    if(Detector.webgl) {
        renderer = new THREE.WebGLRenderer({antialias:true});
    }
    else {
        renderer = new THREE.CanvasRenderer();
    }
    
    // Set the background color of the renderer to black, with full opacity.
    renderer.setClearColor(0x000000, 1);
    
    // Get the size of the inner window (content area) to create a full size renderer.
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    
    // Set the renderers size to the content areas size.
    renderer.setSize(canvasWidth, canvasHeight);
    
    // Append the renderers DOM.
    document.body.style.margin = 0;
    document.body.style.overflow = 'hidden';
    document.body.appendChild(renderer.domElement);
    
    
    // Create the scene, in which all objects are stored (e. g. camera, lights, geometries, ...).
    scene = new THREE.Scene();
    
    var aspect = canvasWidth / canvasHeight;
    camera = new THREE.PerspectiveCamera(45, aspect, 1, 100);
    camera.position.set(0, 0, 10);
    scene.add(camera);
    
    // The Rubic's cube.
    rubicsCube = new THREE.Object3D();
    scene.add(rubicsCube);
    
    // Click point for page rotation.
    clickPoint = new THREE.Object3D();
    scene.add(clickPoint);
    
    // Rotation
    rubicsCube.rotation.y = Math.PI / 4;
    rubicsCube.rotation.x = Math.PI / 4;
    targetRotationX = 0;
    rotateX = 0;
    targetRotationY = rubicsCube.rotation.y;
    rotateY = Math.PI / 4;
    targetRotationZ = rubicsCube.rotation.z;
    rotateZ = 0;
    xAxis = rotateVector(new THREE.Vector3(1, 0, 0));
    yAxis = rotateVector(new THREE.Vector3(0, 1, 0));
    zAxis = rotateVector(new THREE.Vector3(0, 0, 1));
    
    // Pages.
    var shape = new THREE.PlaneGeometry(3, 3);
    var materials = [
        new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: true, opacity: 0.0 } )
    ];
    //var cover = new THREE.MeshNormalMaterial();
    var cover = new THREE.MeshFaceMaterial( materials );
    var i = 0;
    cubePage[i] = new THREE.Mesh(shape, cover);
    rubicsCube.add(cubePage[i]);
    cubePage[i].position.set(0, 0, 1.6);
    i++;
    cubePage[i] = new THREE.Mesh(shape, cover);
    rubicsCube.add(cubePage[i]);
    cubePage[i].rotation.x = Math.PI;
    cubePage[i].position.set(0, 0, -1.6);
    i++;
    cubePage[i] = new THREE.Mesh(shape, cover);
    rubicsCube.add(cubePage[i]);
    cubePage[i].rotation.x = -Math.PI / 2;
    cubePage[i].position.set(0, 1.6, 0);
    i++;
    cubePage[i] = new THREE.Mesh(shape, cover);
    rubicsCube.add(cubePage[i]);
    cubePage[i].rotation.x = Math.PI / 2;
    cubePage[i].position.set(0, -1.6, 0);
    i++;
    cubePage[i] = new THREE.Mesh(shape, cover);
    rubicsCube.add(cubePage[i]);
    cubePage[i].rotation.y = Math.PI / 2;
    cubePage[i].position.set(1.6, 0, 0);
    i++;
    cubePage[i] = new THREE.Mesh(shape, cover);
    rubicsCube.add(cubePage[i]);
    cubePage[i].rotation.y = -Math.PI / 2;
    cubePage[i].position.set(-1.6, 0, 0);
    
    // Create the cube.
    // When the CanvasRenderer is used, the texture has some distortions.
    // To get rid of this, you only have to increase the number of cube segments.
    // The WebGLRenderer doesn't needs this workaround.
    // Original: var cubeGeometry = new THREE.CubeGeometry(2.0, 2.0, 2.0);
    var cubeGeometry = new THREE.CubeGeometry(1.0, 1.0, 1.0, 4, 4, 4);
    // Load images as textures.
    var cubeTexture = [
        new THREE.ImageUtils.loadTexture("pics/green.jpg"),
        new THREE.ImageUtils.loadTexture("pics/blue.jpg"),
        new THREE.ImageUtils.loadTexture("pics/yellow.jpg"),
        new THREE.ImageUtils.loadTexture("pics/white.jpg"),
        new THREE.ImageUtils.loadTexture("pics/red.jpg"),
        new THREE.ImageUtils.loadTexture("pics/orange.jpg"),
    ];
    
    // Cube colors: yellow, blue, red, green, orange, white
    // Color order:
    //  y   (Top)
    // brgo (Side)
    //  w   (Bottom)
    
    // Define six texture materials.
    var cubeMaterials = [
        // Example for color.
        //new THREE.MeshBasicMaterial({color:0x000000}),
        new THREE.MeshBasicMaterial({map:cubeTexture[0]}),
        new THREE.MeshBasicMaterial({map:cubeTexture[1]}),
        new THREE.MeshBasicMaterial({map:cubeTexture[2]}),
        new THREE.MeshBasicMaterial({map:cubeTexture[3]}),
        new THREE.MeshBasicMaterial({map:cubeTexture[4]}),
        new THREE.MeshBasicMaterial({map:cubeTexture[5]}),
        //new THREE.MeshBasicMaterial({map:cubeTexture[5], side:THREE.DoubleSide}),
    ];
    for (var i = -1; i <= 1; i++) {
        cubeMesh[i] = [];
        rubicsPage[i] = [];
        for (var j = -1; j <= 1; j++) {
            cubeMesh[i][j] = [];
            rubicsPage[i][j] = [];
            for (var k = -1; k <= 1; k++) {
                var cubeMaterialsPiece = cubeMaterials;
                
                // TODO Make the non visible sides black.
                
                // Create a MeshFaceMaterial, which allows the cube to have different materials on each face.
                var cubeMaterial = new THREE.MeshFaceMaterial(cubeMaterialsPiece);
                
                cubeMesh[i][j][k] = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cubeMesh[i][j][k].position.set(i, j, k);
                
                //rubicsCube.add(cubeMesh[i][j][k]);
                
                rubicsPage[i][j][k] = new THREE.Object3D();
                rubicsCube.add(rubicsPage[i][j][k]);
                
                rubicsPage[i][j][k].add(cubeMesh[i][j][k]);
            }
        }
    }
    //cubeMesh = new THREE.Mesh(cubeGeometry, cubeMaterial);
    //cubeMesh.position.set(0.0, 0.0, 0.0);
    //rubicsCube.add(cubeMesh);
}

function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    
    renderer.setSize( window.innerWidth, window.innerHeight );
}

//Rotate an object around an arbitrary axis in object space
var rotObjectMatrix;
function rotateAroundObjectAxis(object, axis, radians) {
    rotObjectMatrix = new THREE.Matrix4();
    rotObjectMatrix.makeRotationAxis(axis.normalize(), radians);

    // old code for Three.JS pre r54:
    // object.matrix.multiplySelf(rotObjectMatrix);      // post-multiply
    // new code for Three.JS r55+:
    object.matrix.multiply(rotObjectMatrix);

    // old code for Three.js pre r49:
    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
    // new code for Three.js r50+:
    object.rotation.setFromRotationMatrix(object.matrix);
}

var rotWorldMatrix;
// Rotate an object around an arbitrary axis in world space       
function rotateAroundWorldAxis(object, axis, radians) {
    rotWorldMatrix = new THREE.Matrix4();
    rotWorldMatrix.makeRotationAxis(axis.normalize(), radians);

    // old code for Three.JS pre r54:
    //  rotWorldMatrix.multiply(object.matrix);
    // new code for Three.JS r55+:
    rotWorldMatrix.multiply(object.matrix);                // pre-multiply

    object.matrix = rotWorldMatrix;

    // old code for Three.js pre r49:
    // object.rotation.getRotationFromMatrix(object.matrix, object.scale);
    // old code for Three.js pre r59:
    // object.rotation.setEulerFromRotationMatrix(object.matrix);
    // code for r59+:
    object.rotation.setFromRotationMatrix(object.matrix);
}

function rotateVector(vector) {
    var axis = new THREE.Vector3( 0, 1, 0 );
    var angle = Math.PI / 4;
    var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
    vector.applyMatrix4( matrix );
    
    var axis = new THREE.Vector3( 1, 0, 0 );
    var angle = Math.PI / 4;
    var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
    vector.applyMatrix4( matrix );
    
    return vector;
}

function rotateXYZ(targetRotation, rotate, axis) {
    var rotatetmp = ( targetRotation - rotate ) * 0.08;
    rotateAroundWorldAxis(rubicsCube, axis, rotatetmp);
    rotate += rotatetmp;
    
    return rotatetmp;
}

function rotatePage(point, x1, y1, z1, x2, y2, z2) {
    var xAxisLocal = new THREE.Vector3(1, 0, 0);
    var yAxisLocal = new THREE.Vector3(0, 1, 0);
    var zAxisLocal = new THREE.Vector3(0, 0, 1);
    
    var rotAngle;
    
    var axisLocal;
    if (x1 == x2) {
        axisLocal = xAxisLocal;
        rotAngle = (Math.PI / 2) * (y1 > y2 ? 1 : -1);
    }
    else if (y1 == y2) {
        axisLocal = yAxisLocal;
        rotAngle = (Math.PI / 2) * (z1 < z2 ? 1 : -1);
    }
    else {
        axisLocal = zAxisLocal;
        rotAngle = (Math.PI / 2) * (y1 > y2 ? 1 : -1);
    }
    
    var x = 0;
    var y = 0;
    var z = 0;
    
    var p = [];
    var pi = 0;
    for (p[0] = -1; p[0] <= 1; p[0]++) {
        for (p[1] = -1; p[1] <= 1; p[1]++) {
            pi = 0;
            var xi = (x1 == x2 ? x : p[pi++]);
            var yi = (y1 == y2 ? y : p[pi++]);
            var zi = (z1 == z2 ? z : p[pi++]);
            rotateAroundObjectAxis(rubicsPage[xi][yi][zi], axisLocal, rotAngle);
        }
    }
    
    mouseState = MOUSE_STATE_RELEASED;
}

function animateScene() {
    requestAnimationFrame(animateScene);
    
    renderer.render(scene, camera);
    
    if (MOUSE_STATE_AXIS_X == mouseState) {
        var rotateXtmp = ( targetRotationX - rotateX ) * 0.2;
        rotateAroundWorldAxis(rubicsCube, xAxis, rotateXtmp);
        rotateX += rotateXtmp;
        if (mouseUp && Math.abs(rotateXtmp) < 0.003) {
            mouseState = MOUSE_STATE_NULL;
            for (var i = 0; i < 100; i++) {
                var rotateXtmp = ( targetRotationX - rotateX ) * 0.08;
                rotateAroundWorldAxis(rubicsCube, xAxis, rotateXtmp);
                rotateX += rotateXtmp;
            }
        }
    }
    else if (MOUSE_STATE_AXIS_Y == mouseState) {
        var rotateYtmp = ( targetRotationY - rotateY ) * 0.2;
        rotateAroundWorldAxis(rubicsCube, yAxis, rotateYtmp);
        rotateY += rotateYtmp;
        if (mouseUp && Math.abs(rotateYtmp) < 0.003) {
            mouseState = MOUSE_STATE_NULL;
            for (var i = 0; i < 100; i++) {
                var rotateYtmp = ( targetRotationY - rotateY ) * 0.08;
                rotateAroundWorldAxis(rubicsCube, yAxis, rotateYtmp);
                rotateY += rotateYtmp;
            }
        }
    }
    else if (MOUSE_STATE_AXIS_Z == mouseState) {
        var rotateZtmp = ( targetRotationZ - rotateZ ) * 0.2;
        rotateAroundWorldAxis(rubicsCube, zAxis, rotateZtmp);
        rotateZ += rotateZtmp;
        if (mouseUp && Math.abs(rotateZtmp) < 0.003) {
            mouseState = MOUSE_STATE_NULL;
            for (var i = 0; i < 100; i++) {
                var rotateZtmp = ( targetRotationZ - rotateZ ) * 0.08;
                rotateAroundWorldAxis(rubicsCube, zAxis, rotateZtmp);
                rotateZ += rotateZtmp;
            }
        }
    }
}

function moveCubePage(degree) {
}
</script>
</body>
</html>
